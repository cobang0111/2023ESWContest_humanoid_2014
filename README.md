## <div align="center">2023 ì œ 21íšŒ ì„ë² ë””ë“œ ì†Œí”„íŠ¸ì›¨ì–´ ê²½ì§„ëŒ€íšŒ - ì§€ëŠ¥í˜• íœ´ë¨¸ë…¸ì´ë“œ </div>
ğŸš€ ì§€ëŠ¥í˜• íœ´ë¨¸ë…¸ì´ë“œ ë¡œë´‡ì„ ì´ìš©í•œ ë¡œë´‡ ê³¨í”„ ê²½ê¸° ìˆ˜í–‰

## <div align="center">Team ì„œê³„</div>
ğŸŒŸ Team Leader  ì´ì°½ì¬ (ì„œê°•ëŒ€í•™êµ ê¸°ê³„ê³µí•™ê³¼ 19)

ğŸŒŸ Team member ê°•ì •í›ˆ (ì„œê°•ëŒ€í•™êµ ê¸°ê³„ê³µí•™ê³¼ 19)

ğŸŒŸ Team member ê¹€ê¸°í›ˆ (ì„œê°•ëŒ€í•™êµ ê¸°ê³„ê³µí•™ê³¼ / ì»´í“¨í„°ê³µí•™ê³¼ 19)

ğŸŒŸ Team member ì´ë„í—Œ (ì„œê°•ëŒ€í•™êµ ê¸°ê³„ê³µí•™ê³¼ 19)

## <div align="center">Video</div>

ğŸš€ See our operation video on the YouTube

[Youtube_link](https://www.youtube.com/watch?si=oTYd6pSQUsP_0D2D&v=IUE--1FHvtU&feature=youtu.be)


<p align="center"><img width="800" src="https://github.com/cobang0111/2023ESWContest_humanoid_2014/blob/main/img/youtube_main.png"></p>


## <div align="center">Competition Summary</div>

ğŸš€ íœ´ë¨¸ë…¸ì´ë“œ ì •ë³´

<p align="center"><img width="800" src="https://github.com/cobang0111/2023ESWContest_humanoid_2014/blob/main/img/MF-RAPI4.png"></p>


ğŸš€ ê²½ê¸°ì¥

- PAR 3
  <p align="center"><img width="800" src="https://github.com/cobang0111/2023ESWContest_humanoid_2014/blob/main/img/par3.png"></p>
  
- PAR 4
  <p align="center"><img width="800" src="https://github.com/cobang0111/2023ESWContest_humanoid_2014/blob/main/img/par4.png"></p>

- DETAIL
  <p align="center"><img width="800" src="https://github.com/cobang0111/2023ESWContest_humanoid_2014/blob/main/img/par_detail.png"></p>


ğŸš€ ê²½ê¸° ê·œì¹™
- íŒ€ë³„ 2ë²ˆì˜ ê²½ê¸°(íŒŒ3+íŒŒ4)ë¥¼ ì§„í–‰í•˜ì—¬, ê°€ì¥ ë‚®ì€ íƒ€ìˆ˜ì˜ ê²½ê¸°ë¥¼ íŒ€ ì ìˆ˜ë¡œ í•œë‹¤.

- íŒŒ3, íŒŒ4 ê°ê° 5ë¶„ìœ¼ë¡œ ì´ 10ë¶„ìœ¼ë¡œ ê²½ê¸° ì‹œê°„ì€ í•œì •ëœë‹¤.

- ì„¸ë¦¬ë¨¸ë‹ˆ ì—¬ë¶€ëŠ” íŒŒ3, íŒŒ4 ê²½ê¸°ë§ˆë‹¤ í™•ì¸ëœë‹¤. (ì„¸ë¦¬ë¨¸ë‹ˆ ë™ì‘ O : -1 , X : 0, ì˜ëª»ëœ ì„¸ë¦¬ë¨¸ë‹ˆ : +1 )

- ê³¨í”„ê³µì„ í‹°ìƒ· 3ê³³ ì¤‘ ì„ì˜ì— ìœ„ì¹˜ì— ë†“ëŠ”ë‹¤.

- ë¡œë´‡ì„ ì°¨ë · ìƒíƒœë¡œ, ì‹œì‘ ìœ„ì¹˜ì— ë†“ê³  ê²½ê¸°ë¥¼ ì‹œì‘í•œë‹¤.

- ê²½ê¸° ì‹œì‘ í›„ ì°¸ê°€ìëŠ” ë” ì´ìƒ ë¡œë´‡ì„ ë§Œì§ˆ ìˆ˜ ì—†ìŒ.

- ë¡œë´‡ì´ ë™ì‘í•  ë•Œë¶€í„° ì‹œê°„ ì¸¡ì • ì‹œì‘

- ì‹œì‘ ìœ„ì¹˜ëŠ” ë§¤ ê²½ê¸° ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŒ.

- ì²« í‹°ìƒ·ì´ ë°–ìœ¼ë¡œ ë‚˜ê°€ëŠ” ê²½ìš° OBë¡œ, í•´ì €ë“œ í‹°ì— ìš´ì˜ìê°€ ê³µì„ ê°–ë‹¤ ë†“ê³ , 2íƒ€ê°€ ì¶”ê°€ëœë‹¤.

- ì„¸ì»¨ë“œ ìƒ· ì´í›„ ë°–ìœ¼ë¡œ ë‚˜ê°€ëŠ” ê²ƒì€ í•´ì €ë“œë¡œ, ë¡œë´‡ ì•ìœ¼ë¡œ ìš´ì˜ìê°€ ê³µì„ ê°–ë‹¤ ë†“ê³ , 1íƒ€ê°€ ì¶”ê°€ëœë‹¤.

- ë¡œë´‡ì´ ë°–ìœ¼ë¡œ ì´íƒˆí•˜ëŠ” ê²½ìš°, í•´ë‹¹ í™€ ì–‘íŒŒ+1íƒ€ë¥¼ ì ìˆ˜ë¡œ ë°›ê³  í•´ë‹¹ í™€ì„ ì¢…ë£Œí•œë‹¤. (ì˜ˆ: íŒŒ3ì˜ ê²½ìš° 7ì )

- ê³µì„ ì¹  ìˆ˜ ì—†ë‹¤ê³  íŒë‹¨ë˜ëŠ” ê²½ìš°, ì°¸ê°€ìëŠ” +1íƒ€ë¥¼ ë°›ê³ , ê³µì˜ ìœ„ì¹˜ë¥¼ ì´ë™ì‹œí‚¬ ìˆ˜ ìˆë‹¤. (ìš´ì˜ìê°€ ê³µì„ ì˜®ê¸´ë‹¤.)

- ê²½ê¸°ì¥ ì§„ë™ ë° ê¸°íƒ€ ìš”ì¸ìœ¼ë¡œ ê³µì´ ì´ë™í•˜ëŠ” ê²ƒì€ ì¸ì •ëœë‹¤. í•˜ì§€ë§Œ í™€ì¸ì˜ ê²½ìš° ê³µì˜ ì›€ì§ì„ì€ ë¬´íš¨ ì²˜ë¦¬ë˜ì–´, ì›ë˜ì˜ ìœ„ì¹˜ë¡œ ê³µì„ ì´ë™ì‹œí‚¨ë‹¤.

- ê²½ê¸°ì¥ì˜ ê¸°ìš¸ê¸°ëŠ” MAX Â±5ë„ ë¯¸ë§Œì˜ ì˜¤ì°¨ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆë‹¤.
  <p align="center"><img width="800" src="https://github.com/cobang0111/2023ESWContest_humanoid_2014/blob/main/img/par_degree.png"></p>
  
- í™€ ì»µì˜ ê¹Šì´ëŠ” ì•½ 12mmë¡œ, ê³µì´ ë“¤ì–´ê°”ë‹¤ ë‚˜ì˜¤ëŠ” ê²ƒì€ ì¸ì •ë˜ì§€ ì•ŠëŠ”ë‹¤.

- ì¤‘ë„ í¬ê¸°ì˜ ê²½ìš° ì–‘íŒŒ +2íƒ€ë¡œ ìµœì¢… ê¸°ë¡ëœë‹¤.(ì˜ˆ: íŒŒ3ì˜ ê²½ìš° 8ì )


## <div align="center">Code</div>

ğŸš€ Code - Python3 Code (r.py)

<p align = "center"> ESW_sg_v231107.py </p>


  
íŒŒì¼ ì‹¤í–‰ ë° ì €ì¥ëœ HSV ë°ì´í„° ë¡œë“œë“œ


 
```python
# -*- coding: utf-8 -*-

import platform
import numpy as np
import argparse
import cv2
import serial
import time
import sys
from threading import Thread
import csv
import math


X_255_point = 0
Y_255_point = 0
X_Size = 0
Y_Size = 0
Area = 0
Angle = 0

#-----------------------------------------------

Top_name = 'mini CTS5 setting'

hsv_Lower = 0

hsv_Upper = 0


hsv_Lower0 = 0

hsv_Upper0 = 0


hsv_Lower1 = 0

hsv_Upper1 = 0


#----------- 

color_num = [   0,  1,  2,  3,  4]


h_max =     [ 255, 65,196,111,110]

h_min =     [  55,  0,158, 59, 74]


s_max =     [ 162,200,223,110,255]

s_min =     [ 114,140,150, 51,133]


v_max =     [  77,151,239,156,255]

v_min =     [   0,95,104, 61,104]


min_area =  [  50, 50, 50, 10, 10]

now_color = 0

serial_use = 1

serial_port =  None

Temp_count = 0

Read_RX =  0

mx,my = 0,0

threading_Time = 5/1000.

Config_File_Name ='Cts5_v1.dat'

#---------------------------------------------------------

```

Code to Real Operation ìƒìˆ˜ ë° í—¤ë“œ ê°ë„ë¥¼ ê¸°ë¡í•˜ëŠ” ê¸€ë¡œë²Œ ë³€ìˆ˜

```python

# CONSTANT

SIZE_CONSTANT = 5.0
DIST_CONSTANT = 0.16
PIXEL_X_EPSILON = 30
PIXEL_Y_EPSILON = 20

# ì‚¬ìš©ì global ë³€ìˆ˜
    
cur_theta = 30
cur_theta_index = 3
head_serial = [101, 102 ,103, 104, 105, 106, 107, 108, 109, 110, 112, 113, 114, 115, 116, 117, 118]


```

ê¸°ë³¸ í•¨ìˆ˜

```python

#-----------------------------------------------

def nothing(x):
    pass

#-----------------------------------------------

def create_blank(width, height, rgb_color=(0, 0, 0)):
    image = np.zeros((height, width, 3), np.uint8)
    color = tuple(reversed(rgb_color))
    image[:] = color
    return image

#-----------------------------------------------

def draw_str2(dst, target, s):
    x, y = target
    cv2.putText(dst, s, (x+1, y+1), cv2.FONT_HERSHEY_PLAIN, 0.8, (0, 0, 0), thickness = 2, lineType=cv2.LINE_AA)
    cv2.putText(dst, s, (x, y), cv2.FONT_HERSHEY_PLAIN, 0.8, (255, 255, 255), lineType=cv2.LINE_AA)

#-----------------------------------------------

def draw_str3(dst, target, s):
    x, y = target
    cv2.putText(dst, s, (x+1, y+1), cv2.FONT_HERSHEY_PLAIN, 1.5, (0, 0, 0), thickness = 2, lineType=cv2.LINE_AA)
    cv2.putText(dst, s, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.5, (255, 255, 255), lineType=cv2.LINE_AA)

#-----------------------------------------------

def draw_str_height(dst, target, s, height):
    x, y = target
    cv2.putText(dst, s, (x+1, y+1), cv2.FONT_HERSHEY_PLAIN, height, (0, 0, 0), thickness = 2, lineType=cv2.LINE_AA)
    cv2.putText(dst, s, (x, y), cv2.FONT_HERSHEY_PLAIN, height, (255, 255, 255), lineType=cv2.LINE_AA)

#-----------------------------------------------

def clock():
    return cv2.getTickCount() / cv2.getTickFrequency()

#-----------------------------------------------

def Trackbar_change(now_color):
    global  hsv_Lower,  hsv_Upper
    hsv_Lower = (h_min[now_color], s_min[now_color], v_min[now_color])
    hsv_Upper = (h_max[now_color], s_max[now_color], v_max[now_color])

#-----------------------------------------------

def Hmax_change(a):
    h_max[now_color] = cv2.getTrackbarPos('Hmax', Top_name)
    Trackbar_change(now_color)

#-----------------------------------------------

def Hmin_change(a):
    h_min[now_color] = cv2.getTrackbarPos('Hmin', Top_name)
    Trackbar_change(now_color)

#-----------------------------------------------

def Smax_change(a):
    s_max[now_color] = cv2.getTrackbarPos('Smax', Top_name)
    Trackbar_change(now_color)

#-----------------------------------------------

def Smin_change(a):
    s_min[now_color] = cv2.getTrackbarPos('Smin', Top_name)
    Trackbar_change(now_color)

#-----------------------------------------------

def Vmax_change(a):
    v_max[now_color] = cv2.getTrackbarPos('Vmax', Top_name)
    Trackbar_change(now_color)

#-----------------------------------------------

def Vmin_change(a):
    v_min[now_color] = cv2.getTrackbarPos('Vmin', Top_name)
    Trackbar_change(now_color)

#-----------------------------------------------

def min_area_change(a):
    min_area[now_color] = cv2.getTrackbarPos('Min_Area', Top_name)
    if min_area[now_color] == 0:
        min_area[now_color] = 1
        cv2.setTrackbarPos('Min_Area', Top_name, min_area[now_color])
    Trackbar_change(now_color)

#-----------------------------------------------

def Color_num_change(a):
    global now_color, hsv_Lower,  hsv_Upper
    now_color = cv2.getTrackbarPos('Color_num', Top_name)
    cv2.setTrackbarPos('Hmax', Top_name, h_max[now_color])
    cv2.setTrackbarPos('Hmin', Top_name, h_min[now_color])
    cv2.setTrackbarPos('Smax', Top_name, s_max[now_color])
    cv2.setTrackbarPos('Smin', Top_name, s_min[now_color])
    cv2.setTrackbarPos('Vmax', Top_name, v_max[now_color])
    cv2.setTrackbarPos('Vmin', Top_name, v_min[now_color])
    cv2.setTrackbarPos('Min_Area', Top_name, min_area[now_color])
    hsv_Lower = (h_min[now_color], s_min[now_color], v_min[now_color])
    hsv_Upper = (h_max[now_color], s_max[now_color], v_max[now_color])

#----------------------------------------------- 

def TX_data(ser, one_byte):  # one_byte= 0~255
    #ser.write(chr(int(one_byte)))          #python2.7
    ser.write(serial.to_bytes([one_byte]))  #python3

#-----------------------------------------------

def RX_data(serial):
    global Temp_count
    try:
        if serial.inWaiting() > 0:
            result = serial.read(1)
            RX = ord(result)
            return RX
        else:
            return 0
    except:
        Temp_count = Temp_count  + 1
        print("Serial Not Open " + str(Temp_count))
        return 0
        pass

#-----------------------------------------------

#*************************

# mouse callback function

def mouse_move(event,x,y,flags,param):
    global mx, my
    if event == cv2.EVENT_MOUSEMOVE:
        mx, my = x, y


# *************************

def RX_Receiving(ser):
    global receiving_exit,threading_Time
    global X_255_point
    global Y_255_point
    global X_Size
    global Y_Size
    global Area, Angle

    receiving_exit = 1
    while True:
        if receiving_exit == 0:
            break
        time.sleep(threading_Time)

        while ser.inWaiting() > 0:
            result = ser.read(1)
            RX = ord(result)
            print ("RX=" + str(RX))

            
# *************************

def GetLengthTwoPoints(XY_Point1, XY_Point2):
    return math.sqrt( (XY_Point2[0] - XY_Point1[0])**2 + (XY_Point2[1] - XY_Point1[1])**2 )

# *************************

def FYtand(dec_val_v ,dec_val_h):
    return ( math.atan2(dec_val_v, dec_val_y) * (180.0 / math.pi))

# *************************

#degree ê°’ì„ ë¼ë””ì•ˆ ê°’ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜

def FYrtd(rad_val ):
    return  (rad_val * (180.0 / math.pi))


# *************************

# ë¼ë””ì•ˆê°’ì„ degree ê°’ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜

def FYdtr(dec_val):
    return  (dec_val / 180.0 * math.pi)

# *************************

def GetAngleTwoPoints(XY_Point1, XY_Point2):
    xDiff = XY_Point2[0] - XY_Point1[0]
    yDiff = XY_Point2[1] - XY_Point1[1]
    cal = math.degrees(math.atan2(yDiff, xDiff)) + 90

    if cal > 90:
        cal =  cal - 180
    return  cal

# *************************


# ************************

def hsv_setting_save():
    global Config_File_Name, color_num
    global color_num, h_max, h_min 
    global s_max, s_min, v_max, v_min, min_area

    try:
    #if 1:
        saveFile = open(Config_File_Name, 'w')
        i = 0
        color_cnt = len(color_num)

        while i < color_cnt:
            text = str(color_num[i]) + ","
            text = text + str(h_max[i]) + "," + str(h_min[i]) + ","
            text = text + str(s_max[i]) + "," + str(s_min[i]) + ","
            text = text + str(v_max[i]) + "," + str(v_min[i]) + ","
            text = text + str(min_area[i])  + "\n"
            saveFile.writelines(text)
            i = i + 1

        saveFile.close()
        print("hsv_setting_save OK")
        return 1

    except:
        print("hsv_setting_save Error~")
        return 0


#************************

def hsv_setting_read():
    global Config_File_Name
    global color_num, h_max, h_min 
    global s_max, s_min, v_max, v_min, min_area

    #try:
    if 1:
        with open(Config_File_Name) as csvfile:
            readCSV = csv.reader(csvfile, delimiter=',')
            i = 0

            for row in readCSV:
                color_num[i] = int(row[0])
                h_max[i] = int(row[1])
                h_min[i] = int(row[2])
                s_max[i] = int(row[3])
                s_min[i] = int(row[4])
                v_max[i] = int(row[5])
                v_min[i] = int(row[6])
                min_area[i] = int(row[7])
                i = i + 1

        csvfile.close()
        print("hsv_setting_read OK")
        return 1

    #except:
    #    print("hsv_setting_read Error~")
    #    return 0

```
 
ì¶”ê°€ ì •ì˜ í•¨ìˆ˜
 

```python
    
# ******************** sg CUSTOMIZE FUNCTION *********************

# ë¬¼ì²´ë¥¼ ì¢Œìš° íƒ€ê²Ÿ ìœ„ì¹˜ì— ë†“ê¸° ìœ„í•´ ë¡œë´‡ ë™ì‘ì„ ë‹¨ í•œ ë²ˆ ì¡°ì ˆí•˜ëŠ” í•¨ìˆ˜
def obj_x_centering(serial_port, obj_x_center, robot_flag, dir_flag):
    # Current head direction left = -1 / center = 0 / right = +1
    global head_dir
    print(" **** X CENTERING ! **** ")
    print("CURRENT HEAD DIR = ", head_dir)

    # ê³µì„ í—¤ë“œë¥¼ ëŒë¦° ìƒíƒœì—ì„œ ì°¾ì•˜ì„ ë•Œ ëª¸ ë°©í–¥ì„ ê³µ ë°©í–¥ìœ¼ë¡œ ë°”ê¾¸ë„ë¡ í•¨
    # í˜„ì¬ í—¤ë“œ ë°©í–¥ì´ ì˜¤ë¥¸ìª½ -> ë¡œë´‡ì„ ë°˜ì‹œê³„ë°©í–¥ìœ¼ë¡œ ëŒë¦¬ê³ , í—¤ë“œë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ë³µê·€
    if head_dir == 1:
        TX_data(serial_port, 19) # Robot rotation to ccw 45'
        time.sleep(3)
        print("ROBOT DIRECTION CHANGE! CounterClockwise")
        TX_data(serial_port, 21) #Head direction to center
        time.sleep(3)
        head_dir = 0
        print("HEAD DIR Changed = ", head_dir)

    # í˜„ì¬ í—¤ë“œ ë°©í–¥ì´ ì™¼ìª½ -> ë¡œë´‡ì„ ì‹œê³„ë°©í–¥ìœ¼ë¡œ ëŒë¦¬ê³ , í—¤ë“œë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ë³µê·€    
    elif head_dir == -1:
        TX_data(serial_port, 25) # Robot rotation to cw 45'
        time.sleep(3)
        print("ROBOT DIRECTION CHANGE! Clockwise")
        TX_data(serial_port, 21) #Head direction to center
        time.sleep(3)
        head_dir = 0
        print("HEAD DIR Changed = ", head_dir)
                            
    # Robot rotation control
    # í•¨ìˆ˜ì— ì…ë ¥ëœ dir_flag ì— ë”°ë¼ ê³µì„ ê¸°ì¤€ìœ¼ë¡œ ë¡œë´‡ì´ ì–´ëŠ ë°©í–¥ìœ¼ë¡œ ê±¸ì–´ê°ˆ ì§€ ê²°ì •     
    # ê³µ ì™¼ìª½ í¸ìœ¼ë¡œ ì´ë™í•˜ë„ë¡ 
    print("dir_flag = ",dir_flag)
    if dir_flag < 0:
        if obj_x_center < ((W_View_size)*5/6) :
            print("object_x_center = ", obj_x_center, "-> Need to turn left!")
            TX_data(serial_port, 4)
            time.sleep(3)
        else :
            print("DIRECTION Satisfied!")
            print("object_x_center = ", obj_x_center)
            robot_flag = 1 # Mean robot satisfy the direction
    # ê³µ ì˜¤ë¥¸ìª½ í¸ìœ¼ë¡œ ì´ë™í•˜ë„ë¡
    elif dir_flag > 0:
        if obj_x_center > ((W_View_size)/6) :
            print("object_x_center = ", obj_x_center, "-> Need to turn right!")
            TX_data(serial_port, 6)
            time.sleep(3)
        else :
            print("robot already satisfy the standard!")
            print("object_x_center = ", obj_x_center)
            robot_flag = 1 # Mean robot satisfy the direction
    # ê³µ ì¤‘ì‹¬ ìª½ìœ¼ë¡œ ì´ë™
    else:
        if obj_x_center < ((W_View_size)/2 * 0.95) :
            print("object_x_center = ", obj_x_center, "-> Need to turn left!")
            TX_data(serial_port, 4)
            time.sleep(3)
        elif obj_x_center > ((W_View_size)/2 * 1.05) :
            print("object_x_center = ", obj_x_center, "-> Need to turn right!")
            TX_data(serial_port, 6)
            time.sleep(3)
        else :
            print("robot already satisfy the standard!")
            robot_flag = 1 

    return robot_flag


#ë¬¼ì²´ë¥¼ í™”ë©´ yì¶• ê°€ìš´ë° ë†“ê¸° ìœ„í•´ ë¡œë´‡ í—¤ë“œ ê°ë„ë¥¼ í•œ ë²ˆ ì¡°ì ˆí•˜ëŠ” í•¨ìˆ˜
def obj_y_centering(serial_port, obj_y_center, head_flag):
    print(" **** Y CENTERING ! **** ")
    global cur_theta
    global cur_theta_index
    # Head position control
    if obj_y_center > (H_View_size)/2 * 1.2 :
        print("object_y_center = ", obj_y_center, "-> Need to head down!")
        if cur_theta_index >= len(head_serial)-1:
            print("HEAD LOWER LIMIT : Impossible! -> cur_theta Inintializing")
            cur_theta = 20
            cur_theta_index = 1
        else:
            cur_theta += 5
            cur_theta_index+=1
            TX_data(serial_port, head_serial[cur_theta_index])
            time.sleep(3)
    elif obj_y_center < (H_View_size)/2 * 0.8:
        print("object_y_center = ", obj_y_center, "-> Need to head up!")
        if cur_theta_index <= 0:
            print("HEAD UPPER LIMIT : Impossible! -> cur_theta Initializing")
            cur_theta = 90
            cur_theta_index = 15
        else:
            cur_theta -= 5
            cur_theta_index-=1
            TX_data(serial_port, head_serial[cur_theta_index])
            time.sleep(3)
    else:
        print("Head already satisfy the standard!")
        head_flag = 1 # Mean head degree satisfied

    return head_flag


```


main Function


```python

# **************************************************

# **************************************************

# **************************************************

if __name__ == '__main__':



    #-------------------------------------

    print ("-------------------------------------")

    print ("(2020-1-20) mini CTS5 Program.  MINIROBOT Corp.")

    print ("-------------------------------------")

    print ("")

    os_version = platform.platform()

    print (" ---> OS " + os_version)

    python_version = ".".join(map(str, sys.version_info[:3]))

    print (" ---> Python " + python_version)

    opencv_version = cv2.__version__

    print (" ---> OpenCV  " + opencv_version)   

    #-------------------------------------

    #---- user Setting -------------------

    #-------------------------------------

    W_View_size = 800 #320  #320  #640
    H_View_size = 500
    #H_View_size = int(W_View_size / 1.777)
    #H_View_size = 600  #int(W_View_size / 1.333)
    
    BPS =  4800  # 4800,9600,14400, 19200,28800, 57600, 115200
    serial_use = 1
    View_select = 0
    
    #-------------------------------------
    
    now_color = 0 #0 = Ball , 1 = Flag
    f_count = 0 # frame count variable
    
    #-------------------------------------

    print(" ---> Camera View: " + str(W_View_size) + " x " + str(H_View_size) )
    print ("")
    print ("-------------------------------------")

    #-------------------------------------

    try:
        hsv_setting_read()

    except:
        hsv_setting_save()

    #-------------------------------------

    ap = argparse.ArgumentParser()
    ap.add_argument("-v", "--video",
                    help="path to the (optional) video file")
    ap.add_argument("-b", "--buffer", type=int, default=64,
                    help="max buffer size")
    args = vars(ap.parse_args())
    img = create_blank(320, 100, rgb_color=(0, 0, 255))
    cv2.namedWindow(Top_name)
    cv2.moveWindow(Top_name,0,0)
    cv2.createTrackbar('Hmax', Top_name, h_max[now_color], 255, Hmax_change)
    cv2.createTrackbar('Hmin', Top_name, h_min[now_color], 255, Hmin_change)
    cv2.createTrackbar('Smax', Top_name, s_max[now_color], 255, Smax_change)
    cv2.createTrackbar('Smin', Top_name, s_min[now_color], 255, Smin_change)
    cv2.createTrackbar('Vmax', Top_name, v_max[now_color], 255, Vmax_change)
    cv2.createTrackbar('Vmin', Top_name, v_min[now_color], 255, Vmin_change)
    cv2.createTrackbar('Min_Area', Top_name, min_area[now_color], 255, min_area_change)
    cv2.createTrackbar('Color_num', Top_name,color_num[now_color], 4, Color_num_change)

    Trackbar_change(now_color)

    draw_str3(img, (15, 25), 'MINIROBOT Corp.')
    draw_str2(img, (15, 45), 'space: Fast <=> Video and Mask.')
    draw_str2(img, (15, 65), 's, S: Setting File Save')
    draw_str2(img, (15, 85), 'Esc: Program Exit')

    cv2.imshow(Top_name, img)

    #---------------------------

    if not args.get("video", False):
        camera = cv2.VideoCapture(0)

    else:
        camera = cv2.VideoCapture(args["video"])

    #---------------------------

    camera.set(3, W_View_size)
    camera.set(4, H_View_size)
    camera.set(5, 60)
    time.sleep(0.5)

    #---------------------------

    (grabbed, frame) = camera.read()
    draw_str2(frame, (5, 15), 'X_Center x Y_Center =  Area' )
    draw_str2(frame, (5, H_View_size - 5), 'View: %.1d x %.1d.  Space: Fast <=> Video and Mask.'
                      % (W_View_size, H_View_size))
    draw_str_height(frame, (5, int(H_View_size/2)), 'Fast operation...', 3.0 )
    mask = frame.copy()
    cv2.imshow('mini CTS5 - Video', frame )
    cv2.imshow('mini CTS5 - Mask', mask)
    cv2.moveWindow('mini CTS5 - Mask',322 + W_View_size,36)
    cv2.moveWindow('mini CTS5 - Video',322,36)
    cv2.setMouseCallback('mini CTS5 - Video', mouse_move)

    #---------------------------

    if serial_use != 0:  # python3
    #if serial_use <> 0:  # python2.7
        BPS =  4800  # 4800,9600,14400, 19200,28800, 57600, 115200

        #---------local Serial Port : ttyS0 --------

        #---------USB Serial Port : ttyAMA0 --------

        serial_port = serial.Serial('/dev/ttyS0', BPS, timeout=0.01)
        serial_port.flush() # serial cls
        time.sleep(0.5)

        serial_t = Thread(target=RX_Receiving, args=(serial_port,))
        serial_t.daemon = True
        serial_t.start()


    # First -> Start Code Send 

    TX_data(serial_port, 250)
    TX_data(serial_port, 250)
    TX_data(serial_port, 250)
    TX_data(serial_port, 21)

    old_time = clock()

    View_select = 0
    msg_one_view = 0

```

Main Operation Loop 

```python

    # -------- Main Loop Start --------

    detect_count_ball = 0 # Ball frame count ë³€ìˆ˜
    detect_count_flag = 0 # Flag frame count ë³€ìˆ˜
    
    detect_count_2 = 0 # non-use
    detect_count_3 = 0 # non-use
    detect_count_4 = 0 # non-use

    non_detect_count = 0 # nothing detected frame count ë³€ìˆ˜

    head_condition = 0 # ë¡œë´‡ ì‹œì•¼ Y ì¤‘ì‹¬ì— ê³µì´ ìœ„ì¹˜í–ˆëŠ”ì§€ íŒë‹¨í•˜ëŠ” bool ë³€ìˆ˜
    robot_condition = 0 # ë¡œë´‡ ì‹œì•¼ X ì¤‘ì‹¬ì— ê³µì´ ìœ„ì¹˜í–ˆëŠ”ì§€ íŒë‹¨í•˜ëŠ” bool ë³€ìˆ˜
    
    head_dir = 0 # í˜„ì¬ ë¡œë´‡ì˜ í—¤ë“œ ë°©í–¥ / -1 = left / 0 = center / 1 = right

    ball_theta = 0 # ê³µì´ ì¸ì‹ëœ í—¤ë“œ ìƒí•˜ ê°ë„ ê¸°ë¡ ë³€ìˆ˜
    ball_theta_index = -1 # ê³µì˜ serial array index ê¸°ë¡ ë³€ìˆ˜
    
    same_flag = 0 # ê¹ƒë°œ - ê³µ - ë¡œë´‡ ìˆœìœ¼ë¡œ ì¼ë ¬ ë°°ì—´ëœ ìƒíƒœì¸ì§€ íŒë‹¨í•˜ëŠ” bool ë³€ìˆ˜
    shot_flag = 0 # same_flag = 1ì¼ ë•Œ, shot ì´ ê°€ëŠ¥í•œ ê±°ë¦¬ì¸ì§€ íŒë‹¨í•˜ëŠ” bool ë³€ìˆ˜
    shot_turn_flag = 0 #shot_flag = 1ì¼ ë•Œ, turn í•˜ì—¬ ê¹ƒë°œì´ ë¡œë´‡ ì¢Œì¸¡ì— ìˆìŒì„ ë‚˜íƒ€ë‚´ëŠ” bool ë³€ìˆ˜
    far_flag = 0 # ê³µê³¼ ë¡œë´‡ì˜ ê±°ë¦¬ê°€ ë¨¼ ìƒíƒœì¸ì§€ íŒë‹¨í•˜ëŠ” bool ë³€ìˆ˜

    flag_detected = 0 # ì´ˆê¸° ìƒíƒœì—ì„œ ê³µ íƒì§€ ì´ì „ì— ê¹ƒë°œì„ íƒì§€í–ˆìŒì„ ë‚˜íƒ€ë‚´ëŠ” bool ë³€ìˆ˜ 
    flag_check = 0 # ê³µê³¼ ê¹ƒë°œì´ í•œ ì‹œì•¼ì— ë“¤ì–´ì˜¤ì§€ ì•Šì„ ë•Œ ê¹ƒë°œ ì¢Œí‘œë¥¼ ê¸°ë¡í–ˆìŒì„ ë‚˜íƒ€ë‚´ëŠ” bool ë³€ìˆ˜
    saming = 0 #ê³µê³¼ ê¹ƒë°œì´ í•œ ì‹œì•¼ì— ë“¤ì–´ì˜¤ì§€ ì•Šì„ ë•Œ ê¹ƒë°œ- ê³µ - ë¡œë´‡ ì¼ë ¬ ì •ë ¬ì„ ë§ì¶”ëŠ” ê³¼ì •ì„ ìˆ˜í–‰ ì¤‘ì„ì„ ë‚˜íƒ€ë‚´ëŠ” bool ë³€ìˆ˜
    
    ball_flag = 0 # ê³µì´ ì¸ì‹ëœ í—¤ë“œ ì¢Œìš° ë°©í–¥ì„ ê¸°ë¡í•˜ëŠ” ë³€ìˆ˜
    flag_flag = 0 # ê¹ƒë°œì´ ì¸ì‹ëœ í—¤ë“œ ì¢Œìš° ë°©í–¥ì„ ê¸°ë¡í•˜ëŠ” ë³€ìˆ˜
    long = 0 # ê³µê³¼ ê¹ƒë°œì´ ë°˜ëŒ€ ë°©í–¥ì— ìˆëŠ” ê²½ìš°ë¥¼ ê¸°ë¡í•˜ëŠ” ë³€ìˆ˜

    direction_flag = 0 # ë¡œë´‡ ë³´í–‰ ë°©í–¥ì„ ê²°ì •í•˜ëŠ” ë³€ìˆ˜ / -1 = ê³µì˜ ì™¼ìª½ / 0 = ê³µ ì •ë©´ / 1 = ê³µì˜ ì˜¤ë¥¸ìª½ 
    
    flag_x_center = 0 # ê¹ƒë°œì˜ í™”ë©´ ìƒ pixel x ì¢Œí‘œë¥¼ ì €ì¥í•˜ëŠ” ë³€ìˆ˜
    flag_y_center = 0 # ê¹ƒë°œì˜ í™”ë©´ ìƒ pixel y ì¢Œí‘œë¥¼ ì €ì¥í•˜ëŠ” ë³€ìˆ˜
    ball_x_center = 0 # ê³µì˜ í™”ë©´ ìƒ pixel x ì¢Œí‘œë¥¼ ì €ì¥í•˜ëŠ” ë³€ìˆ˜
    ball_y_center = 0 # ê³µì˜ í™”ë©´ ìƒ pixel y ì¢Œí‘œë¥¼ ì €ì¥í•˜ëŠ” ë³€ìˆ˜
    
    # MAIN LOOP until ceremony
    while True:

        # grab the current frame
        (grabbed, frame) = camera.read()
        if args.get("video") and not grabbed:
            break

        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2YUV)  # HSV => YUV
        # Mask using now_color
        # Not affect to real
        mask = cv2.inRange(hsv, hsv_Lower, hsv_Upper)
        hsv_Lower = (h_min[now_color], s_min[now_color], v_min[now_color])
        hsv_Upper = (h_max[now_color], s_max[now_color], v_max[now_color])
        
        # mask0 -> ball mask
        mask0 = cv2.inRange(hsv, (h_min[0], s_min[0], v_min[0]), (h_max[0], s_max[0], v_max[0]))
        # mask1 -> flag mask
        mask1 = cv2.inRange(hsv, (h_min[1], s_min[1], v_min[1]), (h_max[1], s_max[1], v_max[1]))
        '''
        mask2 = cv2.inRange(hsv, (h_min[2], s_min[2], v_min[2]), (h_max[2], s_max[2], v_max[2]))
        mask3 = cv2.inRange(hsv, (h_min[3], s_min[3], v_min[3]), (h_max[3], s_max[3], v_max[3]))
        mask4 = cv2.inRange(hsv, (h_min[4], s_min[4], v_min[4]), (h_max[4], s_max[4], v_max[4]))
        '''

        mask = cv2.erode(mask, None, iterations=1)
        mask = cv2.dilate(mask, None, iterations=1)
        mask0 = cv2.erode(mask0, None, iterations=1)
        mask0 = cv2.dilate(mask0, None, iterations=1)
        mask1 = cv2.erode(mask1, None, iterations=1)
        mask1 = cv2.dilate(mask1, None, iterations=1)

        #mask = cv2.GaussianBlur(mask, (5, 5), 2)  # softly

        # Detecting
        #cnts = cv2.findContours(mask.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-2]
        cnts0 = cv2.findContours(mask0.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-2]
        cnts1 = cv2.findContours(mask1.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-2]
        '''
        cnts2 = cv2.findContours(mask2.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-2]
        cnts3 = cv2.findContours(mask3.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-2]
        cnts4 = cv2.findContours(mask4.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-2]
        '''
        center = None

```


ì‹œì•¼ ë‚´ ê³µ ê°ì§€ Counting

```python

        # *********************  Ball detected  **************************
        if len(cnts0) > 0:
            c0 = max(cnts0, key=cv2.contourArea)
            #((X, Y), radius) = cv2.minEnclosingCircle(c0)

            Area0 = cv2.contourArea(c0) / min_area[0]
            if Area0 > 255:
                Area0 = 255

            if Area0 > min_area[0]:
                detect_count_ball += 1 

                x0, y0, w0, h0 = cv2.boundingRect(c0)
                
                cv2.rectangle(frame, (x0, y0), (x0 + w0, y0 + h0), (0, 0, 255), 2)
            
            else:
                TX_data(serial_port, 1) # turn left shortly
                time.sleep(2)

```

ì‹œì•¼ ë‚´ ê¹ƒë°œ ê°ì§€ counting

```python

        # *********************  Flag detected  **************************
        if len(cnts1) > 0:
            c1 = max(cnts1, key=cv2.contourArea)
            #((X, Y), radius) = cv2.minEnclosingCircle(c1)

            Area1 = cv2.contourArea(c1) / min_area[1]
            if Area1 > 255:
                Area1 = 255

            if Area1 > min_area[1]:
                detect_count_flag += 1

                x1, y1, w1, h1 = cv2.boundingRect(c1)
                
                cv2.rectangle(frame, (x1, y1), (x1 + w1, y1 + h1), (0, 255, 255), 2)

            else:
                TX_data(serial_port, 1) # turn left shortly
                time.sleep(2)

```

ì‹œì•¼ ë‚´ detecting object ì¡´ì¬í•˜ì§€ ì•ŠìŒ

```python


        # *********************  nothing detected  **************************
        if len(cnts0) <= 0 and len(cnts1) <= 0:
            x = 0
            y = 0
            X_255_point = 0
            Y_255_point = 0
            X_Size = 0
            Y_Size = 0
            Area0 = 0
            Area1 = 0
            Angle = 0
            non_detect_count += 1

```


object detection ê¸°ë°˜ ì¡°ê±´ë¬¸ ìˆ˜í–‰


ê³µ ê°ì§€ & shot_flag = 1 & shot_turn_flag = 1

ê³µì˜ ìœ„ì¹˜ë¥¼ í™”ë©´ Width ì˜ 3/4ì— ë„ë‹¬í•  ë•Œ ê¹Œì§€ ì™¼ìª½ìœ¼ë¡œ ì›€ì§ì´ê³ , ë„ë‹¬ ì‹œ ê³µí”„ê³µì„ íƒ€ê²©í•œë‹¤. 
íƒ€ê²© í›„ì— ëª¨ë“  ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™” í•˜ê³  ê³µì„ íƒ€ê²©í•œ ë°©í–¥ìœ¼ë¡œ ëª¸ì„ëŒë¦°ë‹¤. 
ìƒí™©ì— ëŒ€í•œ ì˜ˆì‹œëŠ” ë‹¤ìŒ ê·¸ë¦¼ê³¼ ê°™ë‹¤.

<p align="center"><img width="800" src="https://github.com/cobang0111/2023ESWContest_humanoid_2014/blob/main/img/1_shot_turn.png"></p>
 

```python

        # *********************  ë¡œë´‡ ë™ì‘ ì¡°ê±´ ë¶„ê¸° ì‹œì‘  **************************

        # ********* ëª¨ë“  ë™ì‘ì€ ì•ˆì •ì„±ì„ ìœ„í•´ 20í”„ë ˆì„ ê°ì§€ ë˜ì—ˆì„ ë•Œ ìˆ˜í–‰ë¨ ***********


        # ********************* Action : ë¡œë´‡ì´ ê³¨í”„ê³µì„ íƒ€ê²©  **************************
        # Shot possible (ì¡°ê±´ : ê³µ ê°ì§€, shot flag, shot turn flag -> ê²°ê³¼ : ê³µ ìœ„ì¹˜ ë§ì¶° shot)

        if detect_count_ball > 20 and shot_flag and shot_turn_flag:
            
            print("******* ROBOT SHOT! *********")

            detect_count_ball = 0
            detect_count_flag = 0
            ball_x_center = x0 + w0/2
            ball_y_center = y0 + h0/2
            
            # ì •í™•í•œ íƒ€ê²©ì´ ì´ë£¨ì–´ì§€ëŠ” ë²”ìœ„ê¹Œì§€ ë¡œë´‡ì„ ì™¼ìª½ìœ¼ë¡œ ì´ë™ì‹œí‚´
            if ball_x_center < W_View_size * 0.75:
                TX_data(serial_port, 15) # Move left shortly
                time.sleep(2)

            # ë„ë‹¬ ì‹œ íƒ€ê²© í›„ ë³€ìˆ˜ ì´ˆê¸°í™”
            else:
                TX_data(serial_port, 2) # SHOT
                time.sleep(3)

                # ë³€ìˆ˜ ì´ˆê¸°í™”
                shot_turn_flag = 0
                shot_flag = 0
                robot_condition = 0
                head_condition = 0
                flag_detected = 0
                flag_check = 0
                same_flag = 0
                saming = 0
                far_flag = 0
                ball_theta = 0
                ball_theta_index = -1

                # í—¤ë“œ ìƒí•˜ ê°ë„ ì´ˆê¸°í™”
                cur_theta = 30
                cur_theta_index = 3
                TX_data(serial_port, head_serial[cur_theta_index]) # Head up to 30'
                time.sleep(2)

                # íƒ€ê²©í•œ ì™¼ìª½ ë°©í–¥ìœ¼ë¡œ ë¡œë´‡ íšŒì „
                TX_data(serial_port, 25)
                time.sleep(3)
                TX_data(serial_port, 25)
                time.sleep(3)

```


```python

        # ********** Action : ë¡œë´‡ì´ ê³¨í”„ê³µì„ ì˜¬ë°”ë¥¸ ë°©í–¥ìœ¼ë¡œ íƒ€ê²©í•˜ê¸° ìœ„í•´ íšŒì „  ***********
        # Shot possible but turn is needed (ì¡°ê±´ : ê³µ ê°ì§€, shot flag -> ê²°ê³¼ : ì™¼ìª½ìœ¼ë¡œ ì´ë™ í›„ íšŒì „ )
        elif detect_count_ball > 20 and shot_flag:
            
            print("*** ROBOT TURN BEFORE SHOT! ***")

            detect_count_ball = 0
            detect_count_flag = 0
            ball_x_center = x0 + w0/2
            ball_y_center = y0 + h0/2

            # ê³µì´ ì‹œì•¼ ì¤‘ì‹¬ì— ìˆì§€ ì•Šì„ ê²½ìš° ì´ë¥¼ ë§ì¶¤
            if not robot_condition:
                robot_condition = obj_x_centering(serial_port, ball_x_center, robot_condition, 0)
                continue

            # ê³µ ì™¼ìª½í¸ìœ¼ë¡œ ì´ë™í•˜ì—¬ íšŒì „í•  ìˆ˜ ìˆë„ë¡ ë¡œë´‡ì„ ì™¼ìª½ìœ¼ë¡œ ì´ë™ì‹œí‚´
            if ball_x_center < W_View_size * 0.95:
                TX_data(serial_port, 15) #Move left shortly
                time.sleep(2)

            # ë„ë‹¬ ì‹œ ì™¼ìª½ìœ¼ë¡œ 4ë²ˆ, ì‹œê³„ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „
            else:
                TX_data(serial_port, 15) # Move left shortly
                time.sleep(2)
                TX_data(serial_port, 15) # Move left shortly
                time.sleep(2) 
                TX_data(serial_port, 15) # Move left shortly
                time.sleep(2)
                TX_data(serial_port, 15) # Move left shortly
                time.sleep(2)
                
                TX_data(serial_port, 24) # CW 45'
                time.sleep(3)
                TX_data(serial_port, 24) # CW 45'
                time.sleep(3)
                TX_data(serial_port, 24) # CW 45'
                time.sleep(3)

                # ê¹ƒë°œì„ ë°”ë¼ë³¼ ìˆ˜ ìˆë„ë¡ í—¤ë“œ ë°©í–¥ ì§€ì •
                cur_theta = 20
                cur_theta_index = 1
                TX_data(serial_port, head_serial[cur_theta_index])
                time.sleep(2)
                TX_data(serial_port, 28) # Head direction to left
                time.sleep(2)
                shot_turn_flag = 1 # shot_turn_flag is here

```


```python

        # ******* Action : ë¡œë´‡ê³¼ ê³µì´ ë©€ ë•Œ, ë¡œë´‡ì´ ê³¨í”„ê³µì„ íƒ€ê²©í•˜ê¸° ì¢‹ì€ ê·¼ì²˜ë¡œ ì´ë™  ********
        # Case : ball is far from robot (ì¡°ê±´ : ê³µ ê°ì§€, far_flag -> ê²°ê³¼ : ê³µ ìœ„ì¹˜ ê·¼ì²˜ë¡œ ì´ë™)
        elif detect_count_ball > 20 and far_flag:

            print("*** ROBOT FAR FROM BALL! ***")

            detect_count_ball = 0
            detect_count_flag = 0
            ball_x_center = x0 + w0/2
            ball_y_center = y0 + h0/2

            # ê³µì´ í™”ë©´ Y ì¤‘ì‹¬ì— ìˆì§€ ì•Šì„ ë•Œ        
            if not head_condition:
                head_condition = obj_y_centering(serial_port, ball_y_center, head_condition)
            
            # Y ì¤‘ì‹¬ì´ ì¼ì¹˜í•  ê²½ìš° ê³µê³¼ì˜ ê±°ë¦¬ ê³„ì‚° ë° ê³µ ë°©í–¥ìœ¼ë¡œ íšŒì „
            else:
                # ê±°ë¦¬ ê³„ì‚°
                ball_dist = 33/math.tan(math.radians(cur_theta))
                print("Ball - robot distance = {:.2f} cm".format(ball_dist))
                
                # Case : ê¹ƒë°œ ì™¼ìª½, ê³µ ì˜¤ë¥¸ìª½
                if flag_flag < 0 and ball_flag > 0:
                    direction_flag = 1 # robot directionì´ ê³µì˜ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•˜ë„ë¡

                # Case : ê¹ƒë°œ ì˜¤ë¥¸ìª½, ê³µ ì™¼ìª½
                elif flag_flag > 0 and ball_flag < 0:
                    direction_flag = -1 # robot directionì´ ê³µì˜ ì™¼ìª½ìœ¼ë¡œ ì´ë™í•˜ë„ë¡
                    
                robot_condition = obj_x_centering(serial_port, ball_x_center, robot_condition, direction_flag)
  
                
            # ë³´í–‰í•  ì¤€ë¹„ê°€ ì™„ë£Œëœ ìƒíƒœ(ë°©í–¥ê³¼ ê±°ë¦¬ê°€ ê²°ì •ëœ ìƒíƒœ)
            if head_condition and robot_condition :
                
                print("**** ROBOT MOVE! ****")

                # í—¤ë“œ ìƒí•˜ ê° ì´ˆê¸°í™” ë° ì´ë™
                cur_theta = 30
                cur_theta_index = 3
                TX_data(serial_port, 11) # Move In front
                time.sleep(ball_dist*DIST_CONSTANT*1.3)
                TX_data(serial_port, 26) # Basic Status
                time.sleep(3)
                TX_data(serial_port, 26) # Basic Status
                time.sleep(3)

                # ë¡œë´‡ì„ ê³µ ë°©í–¥ìœ¼ë¡œ íšŒì „
                if direction_flag > 0 :
                    TX_data(serial_port, 22) # CCW 45'
                    time.sleep(3)
                    TX_data(serial_port, 22) # CCW 45'
                    time.sleep(3)
                    TX_data(serial_port, 22) # CCW 45'
                    time.sleep(3)
                    
                elif direction_flag < 0:
                    TX_data(serial_port, 24) # CW 45'
                    time.sleep(3)
                    TX_data(serial_port, 24) # CW 45'
                    time.sleep(3)
                    TX_data(serial_port, 24) # CW 45'
                    time.sleep(3)

                # ë³€ìˆ˜ ì´ˆê¸°í™”
                head_condition = 0
                robot_condition = 0
                head_dir = 0
                far_flag = 0    
                ball_flag = 0
                flag_flag = 0
                direction_flag = 0
                long = 0
                flag_detected = 0
                flag_check = 0
                saming = 0
                ball_theta = 0
                ball_theta_index = -1

                flag_x_center = -100
                flag_y_center = -100
                ball_x_center = -1000
                ball_y_center = -1000

                # ê³µ ê·¼ì²˜ë¡œ í—¤ë“œ ìƒí•˜ ê°ë„ ì¡°ì ˆ
                cur_theta = 70
                cur_theta_index = 11
                TX_data(serial_port, head_serial[cur_theta_index]) 
                time.sleep(2)


```


```python

        # *********** Action : ê³µê³¼ ê¹ƒë°œì´ ì¼ë ¬ ì„ ìƒì— ìœ„ì¹˜í•˜ë„ë¡ ë§ì¶¤(1)  *************
        # Both detected during 20 frame but flag and ball are not in same line
        # ì¡°ê±´ : ë‘˜ ë‹¤ ê°ì§€, ì¼ë ¬ ì•„ë‹Œ ê²½ìš° -> ê²°ê³¼ : ì¼ë ¬ ì •ë ¬ ì‹œë„
        elif detect_count_ball > 20 and detect_count_flag > 30 and not same_flag:
            
            print("****** ROBOT SORTING! ******")

            detect_count_ball = 0
            detect_count_flag = 0
            ball_x_center = x0 + w0/2
            ball_y_center = y0 + h0/2
            flag_x_center = x1 + w1/2
            flag_y_center = y1 + h1/2

            # ê³µì´ ê¹ƒë°œ ì‚¬ê°í˜• ì•ˆì— ìœ„ì¹˜ -> ì„¸ë ˆëª¨ë‹ˆ
            if (x1 < x0) and (x0+w0 < x1+w1) and (y1 < y0) and (y0+h0 < y1+h1):
                print("SUCCESS!")
                TX_data(serial_port, 119) #ceremony action
                time.sleep(3)
                break

            # ê³µê³¼ flag ì˜ yì¢Œí‘œê°€ ë™ì¼í•  ê²½ìš° ê³µê³¼ ë¨¼ ê²½ìš°ë¡œ ì„¤ì •
            if (abs(flag_y_center-ball_y_center) < PIXEL_Y_EPSILON):
                far_flag = 1 # far_flag is here
            
            # ê³µê³¼ flag ì˜ xì¢Œí‘œê°€ ë§ì´ ë–¨ì–´ì ¸ ìˆì„ ê²½ìš° ê³µê³¼ ë¨¼ ê²½ìš°ë¡œ ì„¤ì •
            elif (abs(flag_x_center-ball_x_center) > W_View_size*3/4):
                far_flag = 1

            else:
                far_flag = 0

            # ê³µì´ ë©€ì§€ ì•Šì€ ê²½ìš°
            if not far_flag:

                print("******** ROBOT IS CLOSE WITH BALL **********")

                # í—¤ë“œ ë°©í–¥ì´ ì˜¤ë¥¸ìª½ì¼ ê²½ìš° ëª¸ì„ ì‹œê³„ë¡œ ëŒë¦¬ê³  ì¤‘ì‹¬ì„ ë³´ë„ë¡
                if head_dir > 0:
                    TX_data(serial_port, 19) # Robot rotation to cw 45'
                    time.sleep(3)
                    print("ROBOT DIRECTION CHANGE! Clockwise")
                    TX_data(serial_port, 21) #Head direction to center
                    time.sleep(3)
                    head_dir = 0
                    continue

                # í—¤ë“œ ë°©í–¥ì´ ì™¼ìª½ì¼ ê²½ìš° ëª¸ì„ ì‹œê³„ë¡œ ëŒë¦¬ê³  ì¤‘ì‹¬ì„ ë³´ë„ë¡
                elif head_dir < 0:
                    TX_data(serial_port, 25) # Robot rotation to ccw 45'
                    time.sleep(3)
                    print("ROBOT DIRECTION CHANGE! CounterClockwise")
                    TX_data(serial_port, 21) #Head direction to center
                    time.sleep(3)
                    head_dir = 0
                    continue

                # ê¹ƒë°œ ì™¼ìª½, ê³µ ì˜¤ë¥¸ìª½ -> ì˜¤ë¥¸ìª½ìœ¼ë¡œ 1ë³´
                if ball_x_center - flag_x_center > PIXEL_X_EPSILON:
                    TX_data(serial_port, 20) #Move Right
                    time.sleep(3)

                # ê³µ ì™¼ìª½, ê¹ƒë°œ ì˜¤ë¥¸ìª½ -> ì™¼ìª½ìœ¼ë¡œ 1ë³´
                elif ball_x_center - flag_x_center < -PIXEL_X_EPSILON:
                    TX_data(serial_port, 15) #Move Left
                    time.sleep(3)

                # Case : ì¼ë ¬ ì •ë ¬ ì™„ë£Œ
                else:
                    print("ROBOT LOCATION IS ACCEPTABLE - SORTING DONE")
                    same_flag = 1
                    robot_condition = 1
                    continue
                
                # ê³µì´ í™”ë©´ X ì¤‘ì‹¬ì— ì˜¤ë„ë¡ ë¡œë´‡ íšŒì „
                robot_condition = obj_x_centering(serial_port, ball_x_center, robot_condition, 0)
                robot_condition = 0

            # ê³µê³¼ì˜ ê±°ë¦¬ê°€ ë¨¼ ê²½ìš°
            else:
                # far flag ì¡°ê±´ë¬¸ ìˆ˜í–‰ì„ ìœ„í•´ ê³µê³¼ ê¹ƒë°œì˜ ìƒëŒ€ì  ìœ„ì¹˜ ì§€ì •
                # ê³µ ì™¼ìª½ ê¹ƒë°œ ì˜¤ë¥¸ìª½
                if ball_x_center < flag_x_center:
                    flag_flag = 1
                    ball_flag = -1

                # ê³µ ì˜¤ë¥¸ìª½ ê¹ƒë°œ ì™¼ìª½
                elif ball_x_center > flag_x_center:
                    flag_flag = -1
                    ball_flag = 1

                # ê·¸ ì™¸
                else:
                    flag_flag = 0
                    ball_flag = 0

```


```python

        # ********** Action : ê³µê³¼ ê¹ƒë°œì´ ì¼ë ¬ ì„ ìƒì— ìœ„ì¹˜í•˜ë„ë¡ ë§ì¶¤(2)  *************
        # Ball detected during 50 frame but flag and ball are not in same line
        # ì¡°ê±´ : ê³µë§Œ ê°ì§€, ê±°ë¦¬ê°€ ê°€ê¹ì§€ë§Œ ì¼ë ¬ ì•„ë‹Œ ê²½ìš° -> ê²°ê³¼ : ê³µê³¼ ê¹ƒë°œì„ ë²ˆê°ˆì•„ ê°€ë©° í™•ì¸í•˜ì—¬ ì¼ë ¬ ì •ë ¬ ì‹œë„
        elif detect_count_ball > 20 and cur_theta >= 60 and not same_flag:
            
            print("**** SAMING PROCESS START ****")

            saming = 1
            # ball ì‹œì•¼ ê°ë„ ì €ì¥
            ball_flag = head_dir
            ball_theta = cur_theta
            ball_theta_index = cur_theta_index
            detect_count_flag = 0
            detect_count_ball = 0

            # í—¤ë“œ ë°©í–¥ì´ ì˜¤ë¥¸ìª½ ì¼ ë•Œ
            if head_dir > 0:
                print("HEAD ON RIGHT")

                TX_data(serial_port, 21) #Head direction to center
                time.sleep(2)
                head_dir = 0
                    
                # ì˜¤ë¥¸ìª½ìœ¼ë¡œ 3ë³´
                for _ in range(3):
                    TX_data(serial_port, 20) # Move Right
                    time.sleep(2)
                flag_check = 0
            
            # í—¤ë“œ ë°©í–¥ì´ ì™¼ìª½ì¼ ë•Œ
            elif head_dir < 0:
                print("HEAD ON LEFT")

                TX_data(serial_port, 21) #Head direction to center
                time.sleep(2)
                head_dir = 0
                    
                # ì™¼ìª½ìœ¼ë¡œ 3ë³´
                for _ in range(3):
                    TX_data(serial_port, 15) # Move Left
                    time.sleep(2)
                flag_check = 0
                
            # ì•„ì§ flagê°€ í•œë²ˆë„ ê°ì§€ë˜ì§€ ì•Šì€ ê²½ìš° -> flag ë¥¼ ì°¾ëŠ”ë‹¤
            if not flag_check:
                print("flag not checked")
                # Head up to cur_theta
                cur_theta = 20
                cur_theta_index = 1
                TX_data(serial_port, head_serial[cur_theta_index])
                time.sleep(2)

            # ê¹ƒë°œ ì¢Œí‘œê°€ check ëœ ê²½ìš°
            else:
                print("****** FLAG CHEKED! ******")
                ball_x_center = x0 + w0/2
                ball_y_center = y0 + h0/2

                print("ball_x_center = ", ball_x_center)
                print("flag_x_center = ", flag_x_center)

                # ê³µì´ ë¡œë´‡ ì •ë©´ì— ìœ„ì¹˜í•  ê²½ìš° same flag
                if head_dir == 0 and ((W_View_size)/2 * 0.95) < ball_x_center < ((W_View_size)/2 * 1.05) and flag_x_center > W_View_size/2:
                    print("ROBOT LOCATION IS ACCEPTABLE")
                    same_flag = 1
                    continue

                # ê³µ ì˜¤ë¥¸ìª½ , ê¹ƒë°œ ì™¼ìª½ -> ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™
                if ball_x_center - flag_x_center > PIXEL_X_EPSILON:
                    TX_data(serial_port, 13) #Move Right
                    time.sleep(2)
                    TX_data(serial_port, 4) # Turn left shortly
                    time.sleep(2)
                    flag_check = 0
                
                # ê³µ ì™¼ìª½, ê¹ƒë°œ ì˜¤ë¥¸ìª½ -> ì™¼ìª½ìœ¼ë¡œ ì´ë™
                elif ball_x_center - flag_x_center < -PIXEL_X_EPSILON:
                    TX_data(serial_port, 14) #Move Left
                    time.sleep(2)
                    TX_data(serial_port, 6) # Turn right shortly
                    time.sleep(2)
                    flag_check = 0
                
                # ê·¸ ì™¸ same flag
                else:
                    print("ROBOT LOCATION IS ACCEPTABLE")
                    same_flag = 1
                    continue


```


```python

        # ********** Action : ê³µì´ ê°ì§€ë˜ê³  ì¼ë ¬ ì •ë ¬ëœ ìƒíƒœì—ì„œëŠ” ê³µì„ ê¸°ì¤€ìœ¼ë¡œ ë¡œë´‡ ë°©í–¥ì„ ë§ì¶¤  *************
        # Case : ball is detected and ball and ball and flag are in same line but robot direction must be changed
        # ì¡°ê±´ : ê³µ ê°ì§€, ì¼ë ¬ ì •ë ¬, ball x not in center -> ê²°ê³¼ : x centering
        elif detect_count_ball > 20 and same_flag and not robot_condition:
            
            detect_count_ball = 0
            detect_count_flag = 0
            
            ball_x_center = x0 + w0/2
            ball_y_center = y0 + h0/2
            flag_x_center = x1 + w1/2
            flag_y_center = y1 + h1/2
            
            # ê³µê³¼ ë„ˆë¬´ ê°€ê¹Œìš¸ ê²½ìš° í›„ì§„
            if cur_theta >= 80:
                TX_data(serial_port, 12)
                time.sleep(3)
                TX_data(serial_port, 26)
                time.sleep(2)
                cur_theta = 60
                cur_theta_index = 9
                TX_data(serial_port, head_serial[cur_theta_index])
                time.sleep(2)
            
            robot_condition = obj_x_centering(serial_port, ball_x_center, robot_condition, 0)

```


```python


        # ********** Action : ê³µì´ ê°ì§€ë˜ê³  ì¼ë ¬ ì •ë ¬ëœ ìƒíƒœì—ì„œ ê±°ë¦¬ ê³„ì‚° í›„ ë³´í–‰ ì‹œì‘  *************
        # Ready to move in front but distance not calculated
        # ì¡°ê±´ : ê³µ ê°ì§€, ì¼ë ¬ ì •ë ¬, ball x center -> ê²°ê³¼ : y centering í›„ ê±°ë¦¬ ê³„ì‚° í›„ shot ë˜ëŠ” ì§ì§„ ë³´í–‰
        elif detect_count_ball > 20 and same_flag and robot_condition and not shot_flag:
            detect_count_ball = 0
            detect_count_flag = 0

            # ê³µì´ í™”ë©´ Y ì¤‘ì‹¬ì— ì˜¤ì§€ ì•Šì„ ê²½ìš° ì´ë¥¼ ë§ì¶˜ë‹¤.
            if not head_condition:
                ball_x_center = x0 + w0/2
                ball_y_center = y0 + h0/2
                head_condition = obj_y_centering(serial_port, ball_y_center, head_condition)

            # Y centering ì™„ë£Œ ì‹œ ê±°ë¦¬ë¥¼ ê³„ì‚°
            else:
                # Ready to move in front
                ball_dist = 33/math.tan(math.radians(cur_theta))
                print(ball_dist, "cm")

                # ì¶©ë¶„íˆ ê°€ê¹Œìš¸ ê²½ìš° -> shot flag
                if ball_dist < 16:
                    shot_flag = 1 #shot_flag is here
                    print("SHOT POSSIBLE!")
                
                # ê°€ê¹ì§€ ì•Šì€ ê²½ìš° -> ì´ë™
                else:
                    # Move in front
                    TX_data(serial_port, 11)
                    time.sleep(ball_dist*DIST_CONSTANT)
                    TX_data(serial_port, 26)
                    time.sleep(2)
                    TX_data(serial_port, 26)
                    time.sleep(2)

                    # ì´ë™í•œ ìœ„ì¹˜ì—ì„œ ì¦‰ì‹œ ê³µì„ ë³´ë„ë¡ ë¨¸ë¦¬ë¥¼ ë‚´ë¦¼
                    cur_theta = 70
                    cur_theta_index = 11
                    TX_data(serial_port, head_serial[cur_theta_index])
                    time.sleep(2)

                #Initializing 
                head_condition = 0
                robot_condition = 0
                ball_theta = 0
                ball_theta_index = -1

```


```python
        # ********** Action : ê³µì´ ì²˜ìŒ ê°ì§€ëœ ê²½ìš° ê¹ƒë°œì„ ë¨¼ì € ì°¾ê³ , ì´ë¯¸ ê¹ƒë°œ ìœ„ì¹˜ê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš° ê³µ ìœ„ì¹˜ë¡œ ì´ë™ *************
        # only ball detected and upper condition is not true
        # ì¡°ê±´ : ìœ„ ì¡°ê±´ë¬¸ë“¤ì„ í†µê³¼í•˜ì§€ ì•Šê³  ê³µë§Œ ê°ì§€ëœ ê²½ìš° -> ê²°ê³¼ : flagë¥¼ ì°¾ë„ë¡ ê³ ê°œë¥¼ ë“¤ì–´ì˜¬ë¦¬ê±°ë‚˜, ê³µ ìœ„ì¹˜ë¡œ ì´ë™
        elif detect_count_ball > 20 and detect_count_flag < 10:
            
            print(" ****** FAR BALL DETECTED ! ******")
            
            # ê³µ ìœ„ì¹˜ ì •ë³´ë¥¼ ì €ì¥
            ball_flag = head_dir
            ball_theta = cur_theta
            ball_theta_index = cur_theta_index
            detect_count_flag = 0
            detect_count_ball = 0

            # ì•„ì§ flagê°€ í•œë²ˆë„ ê°ì§€ë˜ì§€ ì•Šì€ ê²½ìš° -> flag ë¥¼ ì°¾ëŠ”ë‹¤
            if not flag_detected:
                # Head up to 20'
                cur_theta_index = 20
                cur_theta_index = 1
                TX_data(serial_port, head_serial[cur_theta_index])
                time.sleep(2)
                
                # Case : current head = left 45'
                if head_dir == -1:
                    TX_data(serial_port, 30) #Head to right 45'
                    time.sleep(2)
                    head_dir = 1
                # Case : current head = 0'        
                elif head_dir == 0:
                    TX_data(serial_port, 28) #Head to left 45'
                    time.sleep(2)
                    head_dir = -1
                # Case : current head = right 45'
                else:
                    head_dir = 0
                    TX_data(serial_port, 21) #Head to center
                    time.sleep(2)
                
                    cur_theta += 10
                    cur_theta_index += 2
                
                    cur_theta = cur_theta % 100
                    cur_theta_index = cur_theta_index % len(head_serial)
                
                    TX_data(serial_port, head_serial[cur_theta_index])
                    time.sleep(2)
                    non_detect_count = 0
                    print("CUR_HEAD_DIR = ", head_dir)

            # flag ê°€ í•œë²ˆì´ë¼ë„ íƒì§€ëœ ê²½ìš° í•´ë‹¹ ë°©í–¥ì„ ì´ìš©í•˜ì—¬ ì¼ë ¬ ì •ë ¬ì´ ê°€ëŠ¥í•œ ìœ„ì¹˜ë¡œ ì›€ì§ì¸ë‹¤.
            else:
                detect_count_ball = 0
                detect_count_flag = 0

                ball_x_center = x0 + w0/2
                ball_y_center = y0 + h0/2
                        
                # ê³µì´ Y ì¤‘ì‹¬ì— ìˆì§€ ì•Šì„ ê²½ìš° ìœ„ì¹˜ë¥¼ ë§ì¶˜ë‹¤
                if not head_condition:
                    head_condition = obj_y_centering(serial_port, ball_y_center, head_condition)

                # ê³µê³¼ì˜ ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ê³  ì´ë™
                else:
                    ball_dist = 33/math.tan(math.radians(cur_theta))
                    print("Distance with ball = {:.2f} cm".format(ball_dist))

                    # ê¹ƒë°œ ì™¼ìª½, ê³µ ì™¼ìª½ -> robot directionì´ ê³µì˜ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•˜ë„ë¡
                    if flag_flag < 0 and ball_flag < 0 :
                        direction_flag = 1
                    # ê¹ƒë°œ ì™¼ìª½, ê³µ ê°€ìš´ë° -> robot directionì´ ê³µì˜ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•˜ë„ë¡
                    elif flag_flag < 0 and ball_flag == 0:
                        direction_flag = 1
                    # ê¹ƒë°œ ì™¼ìª½, ê³µ ì˜¤ë¥¸ìª½ -> robot directionì´ ê³µì˜ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•˜ë„ë¡
                    elif flag_flag < 0 and ball_flag > 0:
                        direction_flag = 1
                        long = 1
                    # ê¹ƒë°œ ì˜¤ë¥¸ìª½, ê³µ ì™¼ìª½ -> robot directionì´ ê³µì˜ ì™¼ìª½ìœ¼ë¡œ ì´ë™í•˜ë„ë¡
                    elif flag_flag > 0 and ball_flag < 0:
                        direction_flag = -1
                        long = 1
                    # ê¹ƒë°œ ì˜¤ë¥¸ìª½, ê³µ ê°€ìš´ë° -> robot directionì´ ê³µì˜ ì™¼ìª½ìœ¼ë¡œ ì´ë™í•˜ë„ë¡
                    elif flag_flag > 0 and ball_flag == 0:
                        direction_flag = -1
                    # ê¹ƒë°œ ì˜¤ë¥¸ìª½, ê³µ ì˜¤ë¥¸ìª½ -> robot directionì´ ê³µì˜ ì™¼ìª½ìœ¼ë¡œ ì´ë™í•˜ë„ë¡
                    elif flag_flag > 0 and ball_flag > 0:
                        direction_flag = -1
                    # ê¹ƒë°œ ê°€ìš´ë°, ê³µ ì™¼ìª½ -> robot directionì´ ê³µì˜ ì™¼ìª½ìœ¼ë¡œ ì´ë™í•˜ë„ë¡
                    elif flag_flag == 0 and ball_flag < 0:
                        direction_flag = -1
                    # ê¹ƒë°œ ê°€ìš´ë°, ê³µ ê°€ìš´ë° -> robot directionì´ ê³µì˜ ì •ë©´ìœ¼ë¡œ ì´ë™í•˜ë„ë¡
                    elif flag_flag == 0 and ball_flag == 0:
                        direction_flag = 0
                    # ê¹ƒë°œ ê°€ìš´ë°, ê³µ ì˜¤ë¥¸ìª½ -> robot directionì´ ê³µì˜ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•˜ë„ë¡
                    elif flag_flag == 0 and ball_flag > 0:
                        direction_flag = 1
                    # ê·¸ ì™¸ 
                    else:
                        print("Error! Direction flag error")
                        direction_flag = 0

                    if direction_flag > 0 :
                        print("Robot move to right of ball")
                    elif direction_flag < 0 :
                        print("Robot move to left of ball")
                    else:
                        print("Robot move to in front of ball") 

                    robot_condition = obj_x_centering(serial_port, ball_x_center, robot_condition, direction_flag)

                    # ë³´í–‰í•  ì¤€ë¹„ê°€ ì™„ë£Œëœ ìƒíƒœ(ë°©í–¥ê³¼ ê±°ë¦¬ê°€ ê²°ì •ëœ ìƒíƒœ)
                    if head_condition and robot_condition :
                        # ê³µ ìœ„ì¹˜ë¡œ ì´ë™
                        cur_theta = 30
                        cur_theta_index = 3
                        TX_data(serial_port, 11) # ì •ë©´ ì—°ì† ë³´í–‰
                        if long:
                            time.sleep(ball_dist*DIST_CONSTANT*1.6)
                            print("Long")
                        else:
                            time.sleep(ball_dist*DIST_CONSTANT*1.4)
                        TX_data(serial_port, 26) # ì •ì§€
                        time.sleep(3)
                        TX_data(serial_port, 26) # ì •ì§€
                        time.sleep(3)

                        # ê³µ ì˜¤ë¥¸ìª½ í¸ìœ¼ë¡œ ì´ë™í–ˆì„ ê²½ìš°
                        if direction_flag > 0 :
                            TX_data(serial_port, 22) # ccw 45'
                            time.sleep(3)
                            TX_data(serial_port, 22) # ccw 45'
                            time.sleep(3)
                            TX_data(serial_port, 22) # ccw 45'
                            time.sleep(3)

                        elif direction_flag < 0:
                            TX_data(serial_port, 24) # cw 45'
                            time.sleep(3)
                            TX_data(serial_port, 24) # cw 45'
                            time.sleep(3)
                            TX_data(serial_port, 24) # cw 45'
                            time.sleep(3)

                        #Initializing 
                        head_condition = 0
                        robot_condition = 0

                        head_dir = 0
                        ball_flag = 0
                        flag_flag = 0
                        direction_flag = 0
                        flag_detected = 0
                        flag_check = 0
                        saming = 0
                        long = 0

                        ball_theta = 0
                        ball_theta_index = -1

                        flag_x_center = -100
                        flag_y_center = -100
                        ball_x_center = -1000
                        ball_y_center = -1000

                        # ë°”ë¡œ ê³µ ê·¼ì²˜ë¥¼ ë³´ë„ë¡ ì§€ì •
                        cur_theta = 70
                        cur_theta_index = 11
                        TX_data(serial_port, head_serial[cur_theta_index])
                        time.sleep(2)
```


```python

        # ********** Action : shot turn ìƒíƒœì—ì„œ ê¹ƒë°œ ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ shot ë°©í–¥ì„ ì •í™•í•˜ê²Œ ë§ì¶¤ *************
        # flag detected and shot_turn_flag, then control the robot direction 
        # ì¡°ê±´ : ê¹ƒë°œì´ ê°ì§€ë˜ì—ˆê³  shot_turn_flag ìƒíƒœì¸ ê²½ìš° -> ê²°ê³¼ : shotì— ì ì ˆí•œ flag ìœ„ì¹˜ê¹Œì§€ ë¡œë´‡ ê°ë„ë¥¼ ì¡°ì ˆ 
        elif detect_count_flag > 20 and shot_turn_flag:
            detect_count_flag = 0
            detect_count_ball = 0

            flag_x_center = x1+w1/2
            flag_y_center = y1+h1/2

            # flagê°€ í™”ë©´ Y ì¤‘ì‹¬ì— ì˜¤ì§€ ì•Šì„ ê²½ìš° ì´ë¥¼ ë§ì¶¤
            if not head_condition:
                head_condition = obj_y_centering(serial_port, flag_y_center, head_condition)
                continue

            # ê¹ƒë°œ ê±°ë¦¬ ê³„ì‚°
            flag_dist = 33/math.tan(math.radians(cur_theta))
            print("Distance with flag = {:.2f} cm".format(flag_dist))
            
            # ê±°ë¦¬ê°€ 4cm ì´ìƒì´ê³ , ì •í™•í•œ ìœ„ì¹˜ê°€ ì•„ë‹ ê²½ìš°
            if (flag_dist > 40) and (x1+w1 > W_View_size*(3/16)) :
                TX_data(serial_port, 6) # Robot turn left shortly
                time.sleep(2)
            
            # ê·¸ ì™¸ ê²½ìš°ì— ëŒ€í•´ì„œëŠ” ì¦‰ì‹œ shot ê³¼ì • ìˆ˜í–‰
            else:
                TX_data(serial_port, 21)  #Head direction to center
                time.sleep(2)

                # ê³µì„ ë‹¤ì‹œ ë°”ë¼ë³´ë„ë¡ í—¤ë“œë¥¼ ë‚´ë ¤ì¤Œ
                cur_theta = 70
                cur_theta_index = 11
                TX_data(serial_port, head_serial[cur_theta_index])
                time.sleep(2)

        # ********** Action : ê³ ê°œë¥¼ ë²ˆê°ˆì•„ê°€ë©° ê³µê³¼ ê¹ƒë°œì´ ìœ„ì¹˜ë¥¼ ì¼ì¹˜ ì‹œí‚´ *************
        # flag detected during sorting process, then head down to ball and compare with flag coordinate
        # ì¡°ê±´ : ì¼ë ¬ ì •ë ¬ ê³¼ì • ì¤‘ì— flagê°€ ë³´ì¼ ê²½ìš° -> ê²°ê³¼ : ë‹¤ì‹œ ê³ ê°œë¥¼ ë‚´ë ¤ ë¡œë´‡ì˜ ìœ„ì¹˜ë¥¼ ì˜®ê¹€
        elif detect_count_flag > 20 and saming:
            print("flag detected! during saming process")
            
            flag_flag = head_dir
            detect_count_flag = 0
            detect_count_ball = 0

            # flagê°€ ì™¼ìª½ ë°©í–¥ì—ì„œ íƒì§€ëœ ê²½ìš° -> í—¤ë“œë¥¼ ì¤‘ì‹¬, ëª¸ì„ ì¢Œì¸¡ìœ¼ë¡œ ëŒë¦°ë‹¤
            if head_dir == -1:
                TX_data(serial_port, 21) #Head to center
                time.sleep(2)
                TX_data(serial_port, 25) #body to left 45'
                time.sleep(2)
                head_dir = 0
                # ë‹¤ì‹œ ê³µì„ ë³´ë„ë¡ ì„¤ì •
                cur_theta = ball_theta
                cur_theta_index = ball_theta_index
                TX_data(serial_port, head_serial[cur_theta_index])
                time.sleep(2)

            # flagê°€ ì˜¤ë¥¸ìª½ ë°©í–¥ì—ì„œ íƒì§€ëœ ê²½ìš° -> í—¤ë“œë¥¼ ì¤‘ì‹¬, ëª¸ì„ ìš°ì¸¡ìœ¼ë¡œ ëŒë¦°ë‹¤      
            elif head_dir == 1:
                TX_data(serial_port, 21) #Head to center
                time.sleep(2)
                TX_data(serial_port, 19) #body to right 45'
                time.sleep(2)
                head_dir = 0
                # ë‹¤ì‹œ ê³µì„ ë³´ë„ë¡ ì„¤ì •
                cur_theta = ball_theta
                cur_theta_index = ball_theta_index
                TX_data(serial_port, head_serial[cur_theta_index])
                time.sleep(2)
            
            # í˜„ì¬ ê°ë„ê°€ ê³µì„ ë³´ëŠ” ê°ë„ë³´ë‹¤ ìœ„ìª½ì¼ ê²½ìš° -> í—¤ë“œë¥¼ ê³µì„ ë³´ë˜ ê°ë„ë¡œ ë‚´ë¦°ë‹¤
            elif cur_theta < ball_theta:
                flag_check = 1
                flag_x_center = x1 + w1/2 # flag x ì¢Œí‘œ ì €ì¥
                cur_theta = ball_theta
                cur_theta_index = ball_theta_index
                TX_data(serial_port, head_serial[cur_theta_index])
                time.sleep(2)
                flag_y_center = y1 + h1/2 # flag y ì¢Œí‘œ ì €ì¥

            # ìœ„ ê²½ìš°ê°€ ì ìš©ë˜ì§€ ì•Šì•˜ìœ¼ë‚˜ flagê°€ ì¤‘ì‹¬ì—ì„œ íƒì§€ëœ ê²½ìš° -> í—¤ë“œë¥¼ 5ë„ì”© ë‚´ë¦°ë‹¤
            else:
                flag_check = 1
                flag_x_center = x1 + w1/2 # flag x ì¢Œí‘œ ì €ì¥
                cur_theta += 5
                cur_theta_index +=1
                TX_data(serial_port, head_serial[cur_theta_index])
                time.sleep(2)
                flag_y_center = y1 + h1/2 # flag y ì¢Œí‘œ ì €ì¥

```


```python            

        # ********** Action : ê¹ƒë°œì´ ì²˜ìŒ ê´€ì¸¡ë˜ì—ˆì„ ë•Œ ì •ë³´ë¥¼ ì €ì¥í•˜ê³  ë‹¤ì‹œ ê³µì„ ì°¾ëŠ”ë‹¤. *************
        # flag detected during sorting process, then head down to ball and compare with flag coordinate
        # ì¡°ê±´ : flag ê°€ ì²˜ìŒìœ¼ë¡œ detect ëœ ê²½ìš° -> ê²°ê³¼ : flag ì¢Œí‘œ ì •ë³´ë¥¼ ì €ì¥
        elif detect_count_flag > 20 and detect_count_ball < 10:
            flag_detected = 1
            flag_flag = head_dir
            detect_count_flag = 0
            detect_count_ball = 0
            flag_x_center = x1 + w1/2

            # ê³µ ì •ë³´ê°€ ì´ë¯¸ ì¡´ì¬í•  ê²½ìš° í•´ë‹¹ ìƒíƒœë¡œ ëŒì•„ê°
            if ball_theta:
                cur_theta = ball_theta
                cur_theta_index = ball_theta_index
                TX_data(serial_port, 21) #Head to center
                head_dir = 0
                time.sleep(2)
                # Head down to ball_theta
                TX_data(serial_port, head_serial[cur_theta_index])
                time.sleep(2)
                continue
            
            # Case : current head = left 45'
            if head_dir == -1:
                TX_data(serial_port, 30) #Head to right 45'
                time.sleep(2)
                head_dir = 1

            # Case : current head = center     
            elif head_dir == 0:
                TX_data(serial_port, 28) #Head to left 45'
                time.sleep(2)
                head_dir = -1
                    
            # Case : current head = right 45'
            else:
                head_dir = 0
                TX_data(serial_port, 21) #Head to center
                time.sleep(2)
            
                cur_theta += 10
                cur_theta_index += 2
            
                cur_theta = cur_theta % 100
                cur_theta_index = cur_theta_index % len(head_serial)
            
                TX_data(serial_port, head_serial[cur_theta_index])
                time.sleep(3)
                print("CUR_HEAD_DIR = ", head_dir)

```


```python

        # ********** Action : shot_turn_flag ìƒíƒœì—ì„œ ì•„ë¬´ê²ƒë„ ê´€ì¸¡ë˜ì§€ ì•Šì„ ë•Œ ì›ë˜ ìƒíƒœë¡œ ëŒë¦°ë‹¤. *************
        # nothing detected when shot_turn_flag = 1, then change the head direction 
        # ì¡°ê±´ : shot_turn_flagì—ì„œ ì•„ë¬´ê²ƒë„ íƒì§€ë˜ì§€ ì•ŠëŠ” ê²½ìš° -> ê²°ê³¼ : ë‹¤ì‹œ ê³µì„ ë°”ë¼ë³´ë„ë¡ ëŒë ¤ì¤Œ
        elif non_detect_count > 20 and shot_turn_flag:
            detect_count_flag = 0
            detect_count_ball = 0
            non_detect_count = 0

            TX_data(serial_port, 21)  #Head direction to center
            time.sleep(2)

            # ê³µì„ ë‹¤ì‹œ ë°”ë¼ë³´ë„ë¡ í—¤ë“œë¥¼ ë‚´ë ¤ì¤Œ
            cur_theta = 70
            cur_theta_index = 11
            TX_data(serial_port, head_serial[cur_theta_index])
            time.sleep(2)

```


```python

        # ********** Action : ì•„ë¬´ê²ƒë„ ê´€ì¸¡ë˜ì§€ ì•Šì„ ë•Œ objectë¥¼ íƒìƒ‰í•œë‹¤ *************
        # nothing detected, then change the head direction 
        # ì¡°ê±´ : ì•„ë¬´ê²ƒë„ íƒì§€ë˜ì§€ ì•ŠëŠ” ê²½ìš° -> ê²°ê³¼ : flag ì¢Œí‘œ ì •ë³´ë¥¼ ì €ì¥
        elif non_detect_count > 20:

            detect_count_flag = 0
            detect_count_ball = 0
            non_detect_count = 0

            # Case : current head = left 45'
            if head_dir == -1:
                TX_data(serial_port, 30) #Head to right 45'
                time.sleep(2)
                head_dir = 1
                    
            elif head_dir == 0:
                TX_data(serial_port, 28) #Head to left 45'
                time.sleep(2)
                head_dir = -1
                    
            # Case : current head = right 45'
            else:
                head_dir = 0
                TX_data(serial_port, 21) #Head to center
                time.sleep(2)
            
                cur_theta += 10
                cur_theta_index += 2
            
                cur_theta = cur_theta % 100
                cur_theta_index = cur_theta_index % len(head_serial)
            
                TX_data(serial_port, head_serial[cur_theta_index])
                time.sleep(2)
                print("CUR_HEAD_DIR = ", head_dir)
        

```

ì¡°ê±´ ë¶„ê¸° ì¢…ë£Œ, frame check & key interrupt check

```python


        # ********* ë¡œë´‡ ë™ì‘ ì¡°ê±´ ë¶„ê¸° ì¢…ë£Œ *************



        # ***** ì¢…ë£Œ ëª…ë ¹ , fps ì¶œë ¥ ë“± í›„ ì²˜ë¦¬ ê³¼ì • ******

        Frame_time = (clock() - old_time) * 1000.

        old_time = clock()

        f_count += 1
           

        if f_count >= 20: # Fast operation 

            print(" " + str(W_View_size) + " x " + str(H_View_size) + " =  %.1f fps" % (1000/Frame_time))
            print("cur_theta = ", cur_theta, "cur_head_dir = ", head_dir)
            f_count = 0
            #temp = Read_RX

            pass

            
        if View_select == 1: # Debug

            if msg_one_view > 0:

                msg_one_view = msg_one_view + 1

                cv2.putText(frame, "SAVE!", (50, int(H_View_size / 2)),

                            cv2.FONT_HERSHEY_PLAIN, 5, (255, 255, 255), thickness=5)

                

                if msg_one_view > 10:

                    msg_one_view = 0                

                                

            draw_str2(frame, (3, 15), 'X: %.1d, Y: %.1d, Area: %.1d' % (X_255_point, Y_255_point, Area))

            draw_str2(frame, (3, H_View_size - 5), 'View: %.1d x %.1d Time: %.1f ms  Space: Fast <=> Video and Mask.'

                      % (W_View_size, H_View_size, Frame_time))

                      

            #------mouse pixel hsv -------------------------------

            mx2 = mx

            my2 = my

            if mx2 < W_View_size and my2 < H_View_size:

                pixel = hsv[my2, mx2]

                set_H = pixel[0]

                set_S = pixel[1]

                set_V = pixel[2]

                pixel2 = frame[my2, mx2]

                if my2 < (H_View_size / 2):

                    if mx2 < (W_View_size / 2):

                        x_p = -30

                    elif mx2 > (W_View_size / 2):

                        x_p = 60

                    else:

                        x_p = 30

                    draw_str2(frame, (mx2 - x_p, my2 + 15), '-HSV-')

                    draw_str2(frame, (mx2 - x_p, my2 + 30), '%.1d' % (pixel[0]))

                    draw_str2(frame, (mx2 - x_p, my2 + 45), '%.1d' % (pixel[1]))

                    draw_str2(frame, (mx2 - x_p, my2 + 60), '%.1d' % (pixel[2]))

                else:

                    if mx2 < (W_View_size / 2):

                        x_p = -30

                    elif mx2 > (W_View_size / 2):

                        x_p = 60

                    else:

                        x_p = 30

                    draw_str2(frame, (mx2 - x_p, my2 - 60), '-HSV-')

                    draw_str2(frame, (mx2 - x_p, my2 - 45), '%.1d' % (pixel[0]))

                    draw_str2(frame, (mx2 - x_p, my2 - 30), '%.1d' % (pixel[1]))

                    draw_str2(frame, (mx2 - x_p, my2 - 15), '%.1d' % (pixel[2]))

            #----------------------------------------------

            

            cv2.imshow('mini CTS5 - Video', frame )

            cv2.imshow('mini CTS5 - Mask', mask)



        key = 0xFF & cv2.waitKey(1)

        

        if key == 27:  # ESC  Key

            break

        elif key == ord(' '):  # spacebar Key

            if View_select == 0:

                View_select = 1

            else:

                View_select = 0

        elif key == ord('s') or key == ord('S'):  # s or S Key:  Setting valus Save

            hsv_setting_save()

            msg_one_view = 1



    # cleanup the camera and close any open windows

    receiving_exit = 0

    time.sleep(0.5)

    

    camera.release()

    cv2.destroyAllWindows()

```
			  
			  

  


